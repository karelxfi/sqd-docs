---
title: "Migration from Squid SDK"
description: "Guide for Squid SDK users transitioning to Pipes SDK"
---

# Migration from Squid SDK

This guide helps Squid SDK users understand the differences and transition to Pipes SDK.

## Should You Migrate?

Pipes SDK and Squid SDK serve different use cases. Consider Pipes SDK if:

- You need maximum flexibility and control
- You want to minimize dependencies
- You're building custom data pipelines
- You don't need auto-generated GraphQL APIs
- You prefer explicit over implicit behavior

Stick with Squid SDK if:

- You need auto-generated GraphQL APIs
- You want full TypeORM integration
- You prefer schema-driven development
- You need production deployment templates
- You want comprehensive tooling out-of-the-box

<Info>
  You can use both SDKs in different projects. They're complementary tools, not
  mutually exclusive.
</Info>

## Key Differences

### Architecture

**Squid SDK:**

```mermaid
graph LR
    A[Processor] --> B[Batch Handler]
    B --> C[TypeORM Store]
    C --> D[GraphQL Server]
    
    style A fill:#3B82F6,stroke:#1E40AF,stroke-width:2px,color:#fff
    style B fill:#8B5CF6,stroke:#6D28D9,stroke-width:2px,color:#fff
    style C fill:#F59E0B,stroke:#D97706,stroke-width:2px,color:#fff
    style D fill:#10B981,stroke:#059669,stroke-width:2px,color:#fff
```

**Pipes SDK:**

```mermaid
graph LR
    A[Source] --> B[Transformer]
    B --> C[Target]
    
    style A fill:#3B82F6,stroke:#1E40AF,stroke-width:2px,color:#fff
    style B fill:#8B5CF6,stroke:#6D28D9,stroke-width:2px,color:#fff
    style C fill:#10B981,stroke:#059669,stroke-width:2px,color:#fff
```

### Concept Mapping

| Squid SDK                  | Pipes SDK                                  | Notes                        |
| -------------------------- | ------------------------------------------ | ---------------------------- |
| `EvmBatchProcessor`        | `createEvmSource`                          | Data fetching                |
| Batch handler function     | `Transformer`                              | Data processing              |
| `TypeormDatabase`          | `createTarget` or `createClickhouseTarget` | Data persistence             |
| `schema.graphql` + codegen | Manual                                     | No auto-generation           |
| `squid-typeorm-codegen`    | Not applicable                             | Handle schemas yourself      |
| GraphQL server             | Not included                               | Build your own API if needed |

## Migration Examples

### Basic Event Indexing

**Squid SDK:**

```typescript
import { EvmBatchProcessor } from "@subsquid/evm-processor";
import { TypeormDatabase } from "@subsquid/typeorm-store";
import * as usdcAbi from "./abi/usdc";

const processor = new EvmBatchProcessor()
  .setGateway("https://v2.archive.subsquid.io/network/ethereum-mainnet")
  .setRpcEndpoint("https://rpc.ankr.com/eth")
  .setFinalityConfirmation(75)
  .setBlockRange({ from: 20_000_000 })
  .addLog({
    address: ["0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"],
    topic0: [usdcAbi.events.Transfer.topic],
  });

processor.run(new TypeormDatabase(), async (ctx) => {
  const transfers = [];

  for (const block of ctx.blocks) {
    for (const log of block.logs) {
      const { from, to, value } = usdcAbi.events.Transfer.decode(log);
      transfers.push(
        new Transfer({
          id: log.id,
          from,
          to,
          value,
          block: block.header.height,
        })
      );
    }
  }

  await ctx.store.insert(transfers);
});
```

**Pipes SDK:**

```typescript
import { createEvmSource, createEvmDecoder } from "@sqd-pipes/evm-processor";
import { createClickhouseTarget } from "@sqd-pipes/pipes";
import { createClient } from "@clickhouse/client";
import * as usdcAbi from "./abi/usdc";

const source = createEvmSource({
  gateway: "https://v2.archive.subsquid.io/network/ethereum-mainnet",
  chain: "ethereum-mainnet",
  query: {
    range: { from: 20_000_000 },
  },
});

const decoder = source.pipe(
  createEvmDecoder({
    address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    events: {
      transfer: usdcAbi.events.Transfer,
    },
  })
);

const client = createClient({
  host: "http://localhost:8123",
});

const target = createClickhouseTarget({
  client,
  table: "transfers",
  write: async (data, insert) => {
    const rows = data.transfer.map((t) => ({
      block_number: t.block.header.number,
      from_address: t.event.from,
      to_address: t.event.to,
      value: t.event.value.toString(),
    }));
    await insert(rows);
  },
});

async function main() {
  for await (const batch of decoder.read()) {
    await target.write(batch);
  }
}

main().catch(console.error);
```

### Multiple Event Types

**Squid SDK:**

```typescript
processor
  .addLog({
    address: [CONTRACT],
    topic0: [usdcAbi.events.Transfer.topic],
  })
  .addLog({
    address: [CONTRACT],
    topic0: [usdcAbi.events.Approval.topic],
  });

processor.run(db, async (ctx) => {
  for (const block of ctx.blocks) {
    for (const log of block.logs) {
      if (log.topics[0] === usdcAbi.events.Transfer.topic) {
        // Handle transfer
      } else if (log.topics[0] === usdcAbi.events.Approval.topic) {
        // Handle approval
      }
    }
  }
});
```

**Pipes SDK:**

```typescript
const decoder = createEvmDecoder({
  address: CONTRACT,
  events: {
    transfer: usdcAbi.events.Transfer,
    approval: usdcAbi.events.Approval,
  },
});

const pipeline = source.pipe(decoder);

for await (const data of pipeline.read()) {
  // Transfers are in data.transfer
  for (const transfer of data.transfer) {
    // Handle transfer
  }

  // Approvals are in data.approval
  for (const approval of data.approval) {
    // Handle approval
  }
}
```

## Feature Comparison

<AccordionGroup>
<Accordion title="Data Fetching">
  **Both:** Connect to SQD Network for fast historical data
  
  **Squid SDK:** Integrated RPC for real-time sync and state queries
  
  **Pipes SDK:** You handle RPC integration if needed
</Accordion>

<Accordion title="Event Decoding">
  **Both:** Use same ABI typegen tool (`@subsquid/evm-typegen`) **Squid SDK:**
  Decode manually in batch handler **Pipes SDK:** Use `createEvmDecoder` for
  automatic decoding
</Accordion>

<Accordion title="Data Persistence">
  **Squid SDK:** TypeORM with auto-generated entities, migrations, and GraphQL
  schema **Pipes SDK:** Bring your own database. Built-in Clickhouse support
  with progress tracking.
</Accordion>

<Accordion title="GraphQL API">
  **Squid SDK:** Auto-generated from schema.graphql **Pipes SDK:** Not included.
  Build your own if needed.
</Accordion>

<Accordion title="Progress Tracking">
  **Squid SDK:** Automatic via TypeORM database **Pipes SDK:** Automatic with
  Clickhouse targets, manual otherwise
</Accordion>

<Accordion title="Fork Handling">
  **Both:** Full support for blockchain reorganizations
  
  **Squid SDK:** Integrated with TypeORM
  
  **Pipes SDK:** Implement fork callback in targets
</Accordion>
</AccordionGroup>

## Database Migration

### From TypeORM to Clickhouse

**Squid SDK schema.graphql:**

```graphql
type Transfer @entity {
  id: ID!
  from: String! @index
  to: String! @index
  value: BigInt!
  block: Int! @index
  timestamp: DateTime!
}
```

**Equivalent Clickhouse schema:**

```sql
CREATE TABLE transfers (
  id String,
  from_address String,
  to_address String,
  value UInt256,
  block_number UInt64,
  block_timestamp DateTime,

  INDEX from_idx from_address TYPE bloom_filter GRANULARITY 1,
  INDEX to_idx to_address TYPE bloom_filter GRANULARITY 1
)
ENGINE = MergeTree()
ORDER BY (block_number, id)
```

## Common Patterns

### External API Calls

**Squid SDK:**

```typescript
processor.run(db, async (ctx) => {
  for (const transfer of transfers) {
    const metadata = await fetchExternalApi(transfer.tokenId);
    transfer.metadata = metadata;
  }
  await ctx.store.insert(transfers);
});
```

**Pipes SDK:**

```typescript
const enrichmentTransformer = {
  transform: async (data) => {
    return Promise.all(
      data.transfer.map(async (t) => ({
        ...t,
        metadata: await fetchExternalApi(t.tokenId),
      }))
    );
  },
};

const pipeline = source.pipe(decoder).pipe(enrichmentTransformer);
```

### State Queries

**Squid SDK:** Built-in state query support

**Pipes SDK:** Make RPC calls directly:

```typescript
import { ethers } from "ethers";

const provider = new ethers.JsonRpcProvider("https://rpc.ankr.com/eth");

const enrichmentTransformer = {
  transform: async (data) => {
    for (const transfer of data.transfer) {
      const balance = await provider.getBalance(
        transfer.event.to,
        transfer.block.header.number
      );
      transfer.recipientBalance = balance;
    }
    return data;
  },
};
```

## When to Use Each SDK

<CardGroup cols={2}>
  <Card title="Use Squid SDK" icon="server">
    - Need GraphQL API - Want schema-driven development - Prefer integrated
    tooling - Building production indexer with API
  </Card>

  <Card title="Use Pipes SDK" icon="pipe">
    - Maximum flexibility needed - Custom data pipelines - Minimal dependencies
    preferred - No GraphQL API required
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Examples" icon="code" href="/en/sdk/evm/pipes/examples">
    See side-by-side comparison examples
  </Card>

{" "}
<Card
  title="API Reference"
  icon="file-code"
  href="/en/sdk/evm/pipes/api-reference"
>
  Complete Pipes SDK API documentation
</Card>

{" "}
<Card
  title="Data Persistence"
  icon="database"
  href="/en/sdk/evm/pipes/data-persistence"
>
  Learn about Clickhouse integration
</Card>

  <Card
    title="Advanced Patterns"
    icon="rocket"
    href="/en/sdk/evm/pipes/advanced-patterns"
  >
    Explore advanced indexing patterns
  </Card>
</CardGroup>
