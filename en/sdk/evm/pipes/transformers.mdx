---
title: "Transformers"
description: "Process and enrich blockchain data with transformers in Pipes SDK"
---

# Transformers

Transformers process and enrich blockchain data as it flows through your pipeline. They can decode events, aggregate data, add queries dynamically, and compose together to create complex processing logic.

## Basic Transformers

A transformer is an object with a `transform` function:

```typescript
const transformer = {
  transform: async (data) => {
    return data.blocks.map((block) => ({
      blockNumber: block.header.number,
      timestamp: block.header.timestamp,
      eventCount: block.logs.length,
    }));
  },
};
```

### Connecting Transformers

Use the `.pipe()` method to connect a transformer to a source:

```typescript
const pipeline = source.pipe(transformer);

for await (const processedData of pipeline.read()) {
  console.log(processedData);
}
```

## Query from Transformer

Transformers can add queries to the source dynamically using the `query` callback:

```typescript
const USDC_ADDRESS = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
const TRANSFER_TOPIC =
  "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";

const usdcTransformer = {
  query: (builder) => {
    builder.addLog({
      address: [USDC_ADDRESS],
      topic0: [TRANSFER_TOPIC],
    });
  },
  transform: async (data) => {
    const transfers = [];

    for (const block of data.blocks) {
      for (const log of block.logs) {
        if (log.address === USDC_ADDRESS) {
          transfers.push({
            blockNumber: block.header.number,
            transactionHash: log.transactionHash,
            logIndex: log.logIndex,
          });
        }
      }
    }

    return transfers;
  },
};
```

<Tip>
  The `query` callback makes transformers self-contained and reusable. They
  request their own data and process it, making them portable across different
  pipelines.
</Tip>

### Starting with an Empty Query

You can create a source with an empty query and let transformers add all the data requirements:

```typescript
const source = createEvmSource({
  gateway: "https://v2.archive.subsquid.io/network/ethereum-mainnet",
  chain: "ethereum-mainnet",
  query: {
    range: { from: 20_000_000 },
    // No data selection - transformer will add it
  },
});

const pipeline = source.pipe(usdcTransformer);
```

## Composite Transformers

Combine multiple transformers to process different data streams simultaneously:

```typescript
const usdcTransformer = {
  query: (builder) => {
    builder.addLog({
      address: ["0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"],
      topic0: [TRANSFER_TOPIC],
    });
  },
  transform: async (data) => {
    return extractUsdcTransfers(data);
  },
};

const swapTransformer = {
  query: (builder) => {
    builder.addLog({
      address: ["0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640"], // Uniswap V3 WETH-USDC pool
      topic0: [SWAP_TOPIC],
    });
  },
  transform: async (data) => {
    return extractSwaps(data);
  },
};

// Compose them together
const pipeline = source.pipeComposite({
  transfers: usdcTransformer,
  swaps: swapTransformer,
});

for await (const data of pipeline.read()) {
  console.log(data.transfers); // USDC transfer data
  console.log(data.swaps); // Swap event data
}
```

<Info>
  Each transformer in a composite only receives the data it requested through
  its `query` callback.
</Info>

## Event Decoder Transformers

Use `createEvmDecoder` to create transformers that decode smart contract events:

```typescript
import { createEvmDecoder } from "@sqd-pipes/evm-processor";
import * as usdcAbi from "./abi/usdc";

const usdcDecoder = createEvmDecoder({
  address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  events: {
    transfer: usdcAbi.events.Transfer,
  },
});

const pipeline = source.pipe(usdcDecoder);

for await (const data of pipeline.read()) {
  // Events come pre-decoded
  for (const transfer of data.transfer) {
    console.log({
      from: transfer.event.from,
      to: transfer.event.to,
      value: transfer.event.value,
    });
  }
}
```

Learn more in the [EVM Event Decoding](/en/sdk/evm/pipes/evm-event-decoding) guide.

## Chaining Transformers

Chain multiple transformers to create processing pipelines:

```typescript
const decoder = createEvmDecoder({
  address: USDC_ADDRESS,
  events: { transfer: usdcAbi.events.Transfer },
});

const aggregator = {
  transform: async (data) => {
    const summary = {
      totalTransfers: 0,
      totalVolume: 0n,
    };

    for (const transfer of data.transfer) {
      summary.totalTransfers++;
      summary.totalVolume += transfer.event.value;
    }

    return summary;
  },
};

// Chain them together
const pipeline = source.pipe(decoder).pipe(aggregator);
```

## Transformer Patterns

### Filtering

Filter data based on conditions:

```typescript
const filterLargeTransfers = {
  transform: async (data) => {
    return data.transfer.filter(
      (t) => t.event.value > 1_000_000n * 10n ** 6n // > 1M USDC
    );
  },
};
```

### Aggregation

Aggregate data across blocks:

```typescript
const aggregateByAddress = {
  transform: async (data) => {
    const byAddress = new Map();

    for (const transfer of data.transfer) {
      const from = transfer.event.from;
      const current = byAddress.get(from) || { count: 0, volume: 0n };

      byAddress.set(from, {
        count: current.count + 1,
        volume: current.volume + transfer.event.value,
      });
    }

    return Array.from(byAddress.entries()).map(([address, stats]) => ({
      address,
      ...stats,
    }));
  },
};
```

### Enrichment

Add external data or computed fields:

```typescript
const enrichWithMetadata = {
  transform: async (data) => {
    return Promise.all(
      data.transfer.map(async (transfer) => ({
        ...transfer,
        timestamp: transfer.block.header.timestamp,
        valueUsd: await convertToUsd(transfer.event.value),
        receiverType: await classifyAddress(transfer.event.to),
      }))
    );
  },
};
```

## Transformer API Reference

### Transform Function

The `transform` function receives data and returns processed data:

```typescript
{
  transform: async (data: Data) => ProcessedData;
}
```

**Parameters:**

- `data` - The incoming data from the source or previous transformer

**Returns:**

- Any data structure you want to pass to the next stage

### Query Callback

The optional `query` callback adds data requirements to the source:

```typescript
{
  query: (builder: QueryBuilder) => void
}
```

**Available methods on QueryBuilder:**

- `addLog(filter)` - Add event log filters
- `addTransaction(filter)` - Add transaction filters
- `addTrace(filter)` - Add trace filters
- `addStateDiff(filter)` - Add state diff filters

## Best Practices

<AccordionGroup>
<Accordion title="Keep transformers focused">
  Each transformer should have a single, well-defined responsibility. Use composition to combine multiple transformers rather than creating complex monolithic ones.
</Accordion>

<Accordion title="Use query callbacks for self-contained modules">
  When a transformer needs specific data, use the `query` callback so it's
  self-contained and reusable.
</Accordion>

<Accordion title="Return clean data structures">
  Transform raw blockchain data into clean, application-specific structures.
  Don't pass through unnecessary fields.
</Accordion>

<Accordion title="Handle edge cases">
  Check for null/undefined values, validate data formats, and handle
  blockchain-specific edge cases (like zero addresses).
</Accordion>

<Accordion title="Document your transformers">
  Add comments explaining what data the transformer expects and what it returns, especially for reusable modules.
</Accordion>
</AccordionGroup>

## Common Patterns

### Decoding Multiple Events

```typescript
const multiEventDecoder = createEvmDecoder({
  address: CONTRACT_ADDRESS,
  events: {
    transfer: abi.events.Transfer,
    approval: abi.events.Approval,
    mint: abi.events.Mint,
    burn: abi.events.Burn,
  },
});
```

### Processing Multiple Contracts

```typescript
const multiContractPipeline = source.pipeComposite({
  usdc: createEvmDecoder({
    address: USDC_ADDRESS,
    events: { transfer: usdcAbi.events.Transfer },
  }),
  usdt: createEvmDecoder({
    address: USDT_ADDRESS,
    events: { transfer: usdtAbi.events.Transfer },
  }),
});
```

### Conditional Processing

```typescript
const conditionalTransformer = {
  transform: async (data) => {
    const results = [];

    for (const transfer of data.transfer) {
      // Only process transfers above threshold
      if (transfer.event.value > THRESHOLD) {
        results.push(await processLargeTransfer(transfer));
      }
    }

    return results;
  },
};
```

## Next Steps

<CardGroup cols={2}>
  <Card
    title="EVM Event Decoding"
    icon="code"
    href="/en/sdk/evm/pipes/evm-event-decoding"
  >
    Learn about decoding smart contract events
  </Card>

  <Card title="Targets" icon="bullseye" href="/en/sdk/evm/pipes/targets">
    Persist processed data with targets
  </Card>

  <Card title="Examples" icon="lightbulb" href="/en/sdk/evm/pipes/examples">
    See complete transformer examples
  </Card>

  <Card
    title="API Reference"
    icon="file-code"
    href="/en/sdk/evm/pipes/api-reference"
  >
    Complete API documentation
  </Card>
</CardGroup>
