---
title: Development flow
description: A general approach to squid development
---

This page is a definitive end-to-end guide into practical squid development. It uses templates to simplify the process. Check out [Squid from scratch](/en/sdk/squid-sdk/substrate/getting-started/squid-from-scratch) for a more educational barebones approach.

<Info>
  Feel free to also use the template-specific `sqd` scripts defined in
  [`commands.json`](/sdk/squid-cli/commands-json) to simplify your workflow. See
  [sqd CLI cheatsheet](/en/sdk/squid-sdk/substrate/getting-started/cli-cheatsheet) for a
  short intro.
</Info>

## Prepare the environment

- Node v20.x or newer
- Git
- [Squid CLI](/sdk/squid-cli/installation)
- Docker (if your squid will store its data to PostgreSQL)

See also the [Environment set up](/en/sdk/squid-sdk/substrate/getting-started/development-environment-set-up) page.

## Understand your technical requirements

Consider your business requirements and find out

1. How the data should be delivered. Options:
   - [PostgreSQL](/sdk/squid-sdk/data-persistence/typeorm) with an optional [GraphQL API](/sdk/squid-sdk/data-serving/serving-graphql) - can be real-time
   - [file-based dataset](/sdk/squid-sdk/data-persistence/file) - local or on S3
   - [Google BigQuery](/sdk/squid-sdk/data-persistence/bigquery)
2. What data should be delivered
3. What Substrate-based chain you're indexing - see [supported networks](/en/data/networks/substrate)

   Note that you can use SQD via [RPC ingestion](/sdk/squid-sdk/common-topics/unfinalized-blocks) even if your network is not listed.

4. What exact data should be retrieved: events, extrinsics (calls), or storage items
5. Whether you need to mix in any [off-chain data](/sdk/squid-sdk/common-topics/external-api)

## Start from a template \{#templates\}

Although it is possible to [compose a squid from individual packages](/en/sdk/squid-sdk/substrate/getting-started/squid-from-scratch), in practice it is usually easier to start from a template.

### Substrate template

A minimal template intended for developing Substrate squids:

```bash
sqd init my-squid-name -t substrate
```

After retrieving the template install its dependencies:

```bash
cd my-squid-name
npm i
```

Test the template locally:

<Steps>
<Step title="Launch a PostgreSQL container">
```bash
docker compose up -d
```
</Step>

<Step title="Build the squid">```bash npm run build ```</Step>

<Step title="Apply the DB migrations">
  ```bash npx squid-typeorm-migration apply ```
</Step>

<Step title="Start the squid processor">
```bash
node -r dotenv/config lib/main.js
```

You should see output that contains lines like these ones:

```bash
04:11:24 INFO  sqd:processor processing blocks from 6000000
04:11:24 INFO  sqd:processor using archive data source
04:11:24 INFO  sqd:processor prometheus metrics are served at port 45829
04:11:27 INFO  sqd:processor 6051219 / 18079056, rate: 16781 blocks/sec, mapping: 770 blocks/sec, 544 items/sec, eta: 12m
```

</Step>

<Step title="Start the GraphQL server">
Run the following command in a separate terminal:

```bash
npx squid-graphql-server
```

Then visit the [GraphiQL console](http://localhost:4350/graphql) to verify that the GraphQL API is up.

</Step>
</Steps>

When done, shut down and erase your database with `docker compose down`.

## The bottom-up development cycle \{#bottom-up-development\}

The advantage of this approach is that the code remains buildable at all times, making it easier to catch issues early.

### I. Generate type-safe interfaces \{#typegen\}

For Substrate chains, generate TypeScript wrappers for events, calls, and storage:

```bash
npx squid-substrate-typegen typegen.json
```

The `typegen.json` file specifies which events, calls, and storage items to generate types for. See the [Substrate typegen documentation](/en/sdk/squid-sdk/substrate/reference/typegen) for details.

The generated classes will become available in `src/types`.

### II. Configure the data requests \{#processor-config\}

Data requests are [customarily](/en/sdk/squid-sdk/substrate/getting-started/layout) defined at `src/processor.ts`.

Edit the definition of `const processor` to:

1. Set up data sources:
   - Add a [SQD Network gateway](/en/sdk/squid-sdk/substrate/reference/general#set-gateway) for fast data retrieval
   - Add an [RPC endpoint](/en/sdk/squid-sdk/substrate/reference/general#set-rpc-endpoint) (required for metadata)

2. Request the specific [events](/en/sdk/squid-sdk/substrate/reference/data-requests#events), [calls](/en/sdk/squid-sdk/substrate/reference/data-requests#calls), and [storage items](/en/sdk/squid-sdk/substrate/reference/data-requests#storage) your squid needs.

3. [Select all data fields](/en/sdk/squid-sdk/substrate/reference/field-selection) necessary for your task.

See [reference documentation](/en/sdk/squid-sdk/substrate/reference/general) for more info.

### III. Decode and normalize the data \{#batch-handler-decoding\}

Next, change the batch handler to decode and normalize your data.

In templates, the batch handler is defined at the [`processor.run()`](/en/sdk/squid-sdk/reference/processors/architecture#processorrun) call in `src/main.ts` as an inline function. Its sole argument `ctx` contains:

- at `ctx.blocks`: all the requested data for a batch of blocks
- at `ctx.store`: the means to save the processed data
- at `ctx.log`: a [`Logger`](/en/sdk/squid-sdk/reference/logger)
- at `ctx.isHead`: a boolean indicating whether the batch is at the current chain head
- at `ctx._chain`: the means to access RPC for [state queries](/en/sdk/squid-sdk/substrate/reference/typegen/state-queries)

Use the type-safe wrappers from the [typegen step](#typegen) to decode events and calls.

See [Substrate batch context reference](/en/sdk/squid-sdk/substrate/reference/context-interfaces).

### IV. Prepare the store \{#store\}

At `src/main.ts`, change the [`Database`](/sdk/squid-sdk/data-persistence/overview) object definition to accept your output data.

<Steps>
<Step title="Define the database schema">
Define the schema of the database at [`schema.graphql`](/sdk/squid-sdk/reference/schema-file).
</Step>

<Step title="Regenerate the TypeORM model classes">
```bash
npx squid-typeorm-codegen
```

The classes will become available at `src/model`.

</Step>

<Step title="Compile the models code">```bash npm run build ```</Step>

<Step title="Ensure access to a blank database">
The easiest way to do so is to start PostgreSQL in a Docker container with:

```bash
docker compose up -d
```

If the container is running, stop it and erase the database with:

```bash
docker compose down
```

before issuing a `docker compose up -d`.

</Step>

<Step title="Regenerate a migration">
```bash
rm -r db/migrations
```
```bash
npx squid-typeorm-migration generate
```
</Step>
</Steps>

You can now use the async functions [`ctx.store.upsert()`](/sdk/squid-sdk/reference/store/typeorm#upsert) and [`ctx.store.insert()`](/sdk/squid-sdk/reference/store/typeorm#insert) to access the database.

### V. Persist the transformed data \{#batch-handler-persistence\}

For each batch, create all the instances of all TypeORM model classes at once, then save them with the minimal number of calls to `upsert()` or `insert()`.

See the [Batch processing guide](/sdk/squid-sdk/common-topics/batch-processing) for patterns and anti-patterns.

## Next steps

- Learn about [batch processing](/sdk/squid-sdk/common-topics/batch-processing).
- Learn how squids deal with [unfinalized blocks](/sdk/squid-sdk/common-topics/unfinalized-blocks).
- See the [Substrate tutorial](/en/sdk/squid-sdk/substrate/tutorials/substrate) for a complete example.
- Deploy your squid [on own infrastructure](/sdk/squid-sdk/deployment/self-hosting) or to [SQD Cloud](/cloud).

