---
title: "Transformers & Targets"
description: "API reference for transformers and targets"
---

## Event Decoder Transformers

### createEvmDecoder

Create a transformer that decodes smart contract events.

```ts
createEvmDecoder<T>(config: EvmDecoderConfig<T>): Transformer
```

**Returns:** A `Transformer` that transforms `EvmPortalData` into decoded events.

**Parameters:**

- `range`: Block range `{ from: number | 'latest', to?: number }` (required)
- `contracts`: Array of contract addresses or factory (required)
- `events`: Map of event names to ABI objects (required)
- `profiler`: Profiler config `{ id: string }` (optional)

**Example:**

```ts
const transformer = createEvmDecoder({
  range: { from: 20000000, to: 20100000 },
  contracts: ["0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"],
  events: {
    transfer: commonAbis.erc20.events.Transfer,
  },
});
```

<Tip>
Use `@subsquid/evm-typegen` to generate typed ABIs for custom contracts. This provides type safety and eliminates the need to manually find event signatures. See the [Event Decoding guide](/en/sdk/pipes-sdk/core-concepts/event-decoding#custom-abis) for details on generating and using custom ABIs.
</Tip>

<Note>
`createEvmDecoder` returns a `Transformer` that automatically builds the necessary queries for event decoding. You don't need a query builder when using this transformer - it handles query construction internally. However, you still need a portal source.
</Note>

## Generic Transformers

### createTransformer

Transform data in pipes.

```ts
createTransformer<I, O>(config: TransformerConfig<I, O>): Transformer<I, O>
```

**Parameters:**

- `transform`: Transform function `async (data: I, ctx) => O` (required)
- `query`: Query callback `({queryBuilder, portal, logger}) => void` (optional)

**Example:**

```ts
const transformer = createTransformer({
  query: ({ queryBuilder }) => {
    queryBuilder.addLog({
      request: { address: ["0x..."] },
      range: { from: 20000000 },
    });
  },
  transform: async (data) => {
    return data.blocks.map((b) => b.logs);
  },
});
```

## createTarget

Create a data sink.

```ts
createTarget(config: TargetConfig): Target
```

**Parameters:**

- `write`: Write function `async ({ctx, read}) => void` (required)
- `onRollback`: Rollback handler `async ({cursor, type}) => void` (optional)
- `fork`: Fork handler `async (newConsensusBlocks) => BlockCursor | null` (optional)

**Example:**

```ts
const target = createTarget({
  write: async ({ ctx: { logger, profiler }, read }) => {
    for await (const { data } of read()) {
      await database.save(data);
    }
  },
  onRollback: async ({ cursor }) => {
    await database.deleteAfter(cursor.blockNumber);
  },
});
```

## createClickhouseTarget

ClickHouse target with automatic cursor management.

```ts
createClickhouseTarget(config: ClickhouseTargetConfig): Target
```

**Parameters:**

- `client`: ClickHouse client instance (required)
- `onData`: Data handler `async ({store, data, ctx}) => void` (required)
- `onRollback`: Rollback handler `async ({store, cursor, type}) => void` (required)

**Example:**

```ts
const target = createClickhouseTarget({
  client,
  onData: async ({store, data}) => {
    store.insert({
      table: 'transfers',
      values: data.transfer.map(t => ({...})),
      format: 'JSONEachRow'
    })
  },
  onRollback: async ({store, cursor}) => {
    await store.removeAllRows({
      tables: ['transfers'],
      where: `block_number > ${cursor.number}`
    })
  }
})
```

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Sources"
    icon="arrow-left"
    href="/en/sdk/pipes-sdk/reference/sources"
  >
    Sources
  </Card>

  <Card
    title="Query Builder"
    icon="filter"
    href="/en/sdk/pipes-sdk/reference/query-builder"
  >
    Query builder API
  </Card>
</CardGroup>

